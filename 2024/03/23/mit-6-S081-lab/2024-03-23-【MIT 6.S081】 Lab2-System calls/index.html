<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>【MIT 6.S081】 Lab2-System calls | Devil</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【MIT 6.S081】 Lab2-System calls</h1><a id="logo" href="/.">Devil</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【MIT 6.S081】 Lab2-System calls</h1><div class="post-meta">2024-03-23<span> | </span><span class="category"><a href="/categories/OS/">OS</a><a href="/categories/OS/MIT-6-S081/">MIT 6.S081</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-System-calls"><span class="toc-number">1.</span> <span class="toc-text">Lab2-System calls</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9A%84%EF%BC%9F-%E4%BB%A5-write-%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一个系统调用是如何进行的？(以 write 为例)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">总体概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AD%A5%E9%AA%A4%E7%9C%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">分步骤看</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1-%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-write-%E5%85%A5%E6%89%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">step 1: 从系统调用 write 入手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2%EF%BC%9Awrite-%E7%9A%84%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8-ecall"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">step 2：write 的汇编调用 ecall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3%EF%BC%9A%E4%BB%8E-ecall-%E5%88%B0-trampoline"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">step 3：从 ecall 到 trampoline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-4%EF%BC%9A-trampoline-%E4%BB%8E%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%88%B0-void-usertrap-void"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">step 4： trampoline-从保存用户数据到 void usertrap(void)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">保存用户寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%8D%E5%B0%86-%E5%88%9D%E5%A7%8B%E7%94%A8%E6%88%B7%E4%B8%AD%E7%9A%84-a0-%E5%AD%98%E5%88%B0-trapframe-%E4%B8%AD"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">再将 初始用户中的 a0 存到 trapframe 中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.2.4.3.</span> <span class="toc-text">切换内核环境</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-5%EF%BC%9A%E6%89%A7%E8%A1%8C-usertrap"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">step 5：执行 usertrap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-6%EF%BC%9A%E6%89%A7%E8%A1%8C-syscall"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">step 6：执行 syscall()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-7%EF%BC%9A%E5%9B%9E%E5%88%B0-usertrapret-%E6%89%A7%E8%A1%8C-usertrapret"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">step 7：回到 usertrapret() 执行 usertrapret()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-8-%E6%89%A7%E8%A1%8C-trampoline-S-%E4%B8%AD%E7%9A%84-userret"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">step 8: 执行 trampoline.S 中的 userret</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">如何创建一个新的系统调用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step-1%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">step 1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">step 2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-3%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">step 3：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-call-tracing-moderate"><span class="toc-number">1.3.</span> <span class="toc-text">System call tracing (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">具体实施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1%EF%BC%9A%E5%9C%A8-PCB-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AD%98%E5%82%A8-mask-%E7%9A%84-syscall-trace%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA-syscall-trace-%E8%B5%8B%E5%88%9D%E5%A7%8B%E5%80%BC-0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">step 1：在 PCB 中添加存储 mask 的 syscall_trace，以及为 syscall_trace 赋初始值 0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2%EF%BC%9A%E6%B7%BB%E5%8A%A0-uint64-sys-trace-void"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">step 2：添加 uint64 sys_trace(void)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3%EF%BC%9A%E4%BF%AE%E6%94%B9-fork-%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%BF%E5%BE%97-syscall-trace-%E5%BE%97%E4%BB%A5%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">step 3：修改 fork 函数，使得 syscall_trace 得以继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-4%EF%BC%9A%E6%89%80%E6%9C%89%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%83%BD%E4%BC%9A%E8%BF%9B%E5%85%A5-syscall-%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%BF%99%E9%87%8C%E8%BF%9B%E8%A1%8C%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">step 4：所有的系统调用都会进入 syscall 函数，我们在这里进行追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sysinfo-moderate"><span class="toc-number">1.4.</span> <span class="toc-text">Sysinfo (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">具体实施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1%EF%BC%9A%E5%88%9B%E5%BB%BA-get-free-mem"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">step 1：创建 get_free_mem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2%EF%BC%9A%E5%88%9B%E5%BB%BA-get-proc-num"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">step 2：创建 get_proc_num</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-sysinfo"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">step 3：创建系统调用 sysinfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">1.5.</span> <span class="toc-text">Conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">1.6.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol></div></div><div class="post-content"><blockquote>
<p>课程地址：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br>Lab 地址：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a><br>我的代码地址：<a target="_blank" rel="noopener" href="https://github.com/devilran6/devilran-xv6/tree/syscall">https://github.com/devilran6/devilran-xv6/tree/syscall</a><br>Commits：<a target="_blank" rel="noopener" href="https://github.com/devilran6/devilran-xv6/commits/syscall/">https://github.com/devilran6/devilran-xv6/commits/syscall/</a></p>
</blockquote>
<h1 id="Lab2-System-calls"><a href="#Lab2-System-calls" class="headerlink" title="Lab2-System calls"></a>Lab2-System calls</h1><blockquote>
<p>In the last lab you used systems calls to write a few utilities. In this lab you will add some new system calls to xv6, which will help you understand how they work and will expose you to some of the internals of the xv6 kernel. You will add more system calls in later labs.</p>
</blockquote>
<p>给 xv6 添加一些 system calls</p>
<h2 id="一个系统调用是如何进行的？-以-write-为例"><a href="#一个系统调用是如何进行的？-以-write-为例" class="headerlink" title="一个系统调用是如何进行的？(以 write 为例)"></a>一个系统调用是如何进行的？(以 <code>write</code> 为例)</h2><blockquote>
<p>#os&#x2F;todo </p>
</blockquote>
<h3 id="总体概览"><a href="#总体概览" class="headerlink" title="总体概览"></a>总体概览</h3><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p>
<p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>SupervisorMode</code></p>
<p>从 <code>UserMode</code> 到 <code>SupervisorMode</code> 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code> </p>
<p>在 <code>kernel/syscall.c</code> 中调用 <code>void syscall(void)</code> 函数，跳转到 <code>syscalls</code> 这个数组中对应存着的 <code>uint64 sys_write(void)</code> 函数的地址</p>
<p>在 <code>kernel/sysfile.c</code> 中有这 <code>uint64 sys_write(void)</code> 的函数体，执行 <code>write</code> 操作</p>
<p>之后再一步步的返回</p>
<p><img src="/../assets/image-20240321231828744.png"></p>
<h3 id="分步骤看"><a href="#分步骤看" class="headerlink" title="分步骤看"></a>分步骤看</h3><h4 id="step-1-从系统调用-write-入手"><a href="#step-1-从系统调用-write-入手" class="headerlink" title="step 1: 从系统调用 write 入手"></a>step 1: 从系统调用 <code>write</code> 入手</h4><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>我们在正常代码中用的，c语言中的 <code>write</code><br>实际上是系统调用的一个包装，它的函数声明位于 <code>user/user.h</code>，只有一个声明，实际的函数体是由汇编指令洗的，位于 <code>user/usys.S</code></p>
<p>by the way: 如何生成的对应的汇编代码<br><code>user/usys.pl</code> 在 make 后会生成 <code>user/usys.S</code> 文件<br>其中 <code>usys.pl</code> 文件就是一个用于生成对应汇编文件的<strong>脚本文件</strong>，里面一个 <code>entry</code> 函数，<br>调用 <code>entry(&quot;write&quot;)</code>，生成 <code>write</code> 函数对应的汇编代码</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="step-2：write-的汇编调用-ecall"><a href="#step-2：write-的汇编调用-ecall" class="headerlink" title="step 2：write 的汇编调用 ecall"></a>step 2：<code>write</code> 的汇编调用 <code>ecall</code></h4><p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>kernel mode</code></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>我们来具体的看一看汇编代码，它由三条汇编指令构成<br>第一条是将 <code>SYS_write</code> 放到 <code>a7</code> 中，这是一个声明在 <code>syscall.h</code> 中的宏，值为 16.<br>每个 <code>syscall</code> 都有一个对应的宏，叫 <code>System call numbers</code></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br></pre></td></tr></table></figure>

<p>第二条是执行 <code>ecall</code></p>
<p>第三条是 返回</p>
<h4 id="step-3：从-ecall-到-trampoline"><a href="#step-3：从-ecall-到-trampoline" class="headerlink" title="step 3：从 ecall 到 trampoline"></a>step 3：从 <code>ecall</code> 到 <code>trampoline</code></h4><p>从 user mode 到 kernel mode 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code> </p>
<p>ecall 将会做三件事</p>
<ul>
<li>将 <code>pc</code> 存储到 <code>sepc</code></li>
<li>从 <code>user mode</code> 提升到 <code>supervisor mode</code> </li>
<li>跳转到 <code>STVEC</code></li>
</ul>
<blockquote>
<p>#os&#x2F;todo 用 gdb 调试，显示一步步的变化</p>
</blockquote>
<blockquote>
<p>#os&#x2F;q <code>kernelvec.S</code>  这里面的代码是干什么的？ 怎么有说法是说 <code>STVEC</code> 跳转到这里</p>
</blockquote>
<p>现在 <code>pc</code> 指向 <code>STVEC</code> 中的地址，<code>STVEC</code> 寄存器指向的是 <code>0x3ffffff000</code>。<br>这个地址在 用户虚拟地址空间和虚拟地址空间中 都是最顶部的部分，即 <code>trampoline</code></p>
<p><code>trampoline</code> 是蹦床的意思，指的是 从 <code>user mode</code> 跳转到 <code>supervisor mode</code><br>这部分代码是模式转换的关键</p>
<p><strong>trampline 在 usermode 和 supervisormode 之中的虚拟地址映射是相同的</strong><br>这样的好处是，在模式转换的过程中，我们从 user 的页表切换到 kernel 的页表的过程中，程序不会崩溃。<br>因为在 pc 中需要继续运行的虚拟地址是一样的</p>
<p><img src="/../assets/image-20240322101340784.png"></p>
<h4 id="step-4：-trampoline-从保存用户数据到-void-usertrap-void"><a href="#step-4：-trampoline-从保存用户数据到-void-usertrap-void" class="headerlink" title="step 4： trampoline-从保存用户数据到 void usertrap(void)"></a>step 4： <code>trampoline</code>-从保存用户数据到 <code>void usertrap(void)</code></h4><p>Q：等下你可能会好奇？内核中的这些寄存器中的数都是什么时候设置的？<br>ans：从最初启动，到每次中断恢复，都会对内核数据进行设置的</p>
<p>现在我们已经到了 <code>kernel/trampoline.S</code> 中的 <code>trampoline</code>，我们已经是 <code>SupervisorMode</code> 了。<br>但我们现在并不能直接执行 内核代码，因为执行代码需要使用 寄存器。<br>但现在寄存器存储着 <code>UserMode</code> 中暂停时的数据，等执行完内核代码还要进行恢复。</p>
<p>所以我们首先需要保存 <code>UserMode</code> 的寄存器，所有寄存器的数值将保存到 <code>trapframe</code> 中。<br>而 有一个叫 <code>sscratch</code> 的寄存器存储着 <code>trapframe</code> 的地址</p>
<p><code>trapframe</code> 是一个存储所有用户寄存器的结构，在地址空间中位于 <code>trampoline</code> 的下方。<br>值得注意的是：目前执行到这里时，所用的页表还是 <code>UserMode</code> 的页表，还没有进行切换。所以 <code>trapframe</code> 在 <code>UserMode</code> 和 <code>SupervisorMode</code> 中的虚拟地址也是相同的，其通过 <code>UserMode</code> 的页表也可以访问</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">    <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">    <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">    <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">    <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">    <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">    <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">    <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">    <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">    <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">    <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">    <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">    <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">    <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">    <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">    <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">    <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">    <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">    <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">    <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">    <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">    <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">    <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">    <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">    <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">    <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">    <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">    <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">    <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">    <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">    <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">    <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">    <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">    <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">    <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="保存用户寄存器"><a href="#保存用户寄存器" class="headerlink" title="保存用户寄存器"></a>保存用户寄存器</h5><p>首先将调换 <code>sscratch</code> 和 <code>a0</code> 寄存器，此时 <code>a0</code> 寄存器中为 <code>trapframe</code> 的地址，后面即可将所有的用户寄存器都存到 <code>trapframe</code> 中<br>（这样子做的原因是 <code>sd</code> 指令需要用户寄存器执行）</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">trampoline:</span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        <span class="meta"># save user a0 in sscratch so</span></span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># each process has a separate p-&gt;trapframe memory area,</span></span><br><span class="line">        <span class="meta"># but it<span class="string">&#x27;s mapped to the same virtual address</span></span></span><br><span class="line"><span class="string"><span class="meta">        # (TRAPFRAME) in every process&#x27;</span>s user page table.</span></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="再将-初始用户中的-a0-存到-trapframe-中"><a href="#再将-初始用户中的-a0-存到-trapframe-中" class="headerlink" title="再将 初始用户中的 a0 存到 trapframe 中"></a>再将 初始用户中的 <code>a0</code> 存到 <code>trapframe</code> 中</h5><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trapoline.S</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    csrr t0, sscratch</span><br><span class="line">    sd t0, <span class="number">112</span>(a0)</span><br></pre></td></tr></table></figure>

<h5 id="切换内核环境"><a href="#切换内核环境" class="headerlink" title="切换内核环境"></a>切换内核环境</h5><p>现在已经将所有的 用户数据都保存完了，下一步是将 <code>tramframe</code> 中关于内核的数据如 内核页表，内核栈指针… 加载出来，</p>
<ul>
<li>加载栈指针到 <code>sp</code></li>
<li>加载当前处理器的硬件线程ID（HART ID，Hardware Thread ID）到 <code>tp</code></li>
<li>将 <code>usertrap</code> 函数的地址放到 t<code>0</code></li>
<li>加载内核页表到 <code>satp</code></li>
<li>清空 <code>TLB</code>！！！</li>
<li>跳转到 <code>t0</code> 即 <code>usertrap()</code> 函数</li>
</ul>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">        <span class="meta"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">		# 栈指针</span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">		# 将 usertrap() 的地址放到 t0</span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta"># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span></span><br><span class="line">        # 加载内核页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># wait for any previous memory operations to complete, so that</span></span><br><span class="line">        <span class="meta"># they use the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># install the kernel page table.</span></span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        <span class="meta"># flush now-stale user entries from the TLB.</span></span><br><span class="line">        # 清空 TLB</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>

<h4 id="step-5：执行-usertrap"><a href="#step-5：执行-usertrap" class="headerlink" title="step 5：执行 usertrap()"></a>step 5：执行 <code>usertrap()</code></h4><blockquote>
<p>#os&#x2F;todo 这部分等以后再详细补充</p>
</blockquote>
<p>我们主要知道在这里会调用 <code>syscall()</code><br>并在最后会调用 <code>usertrapret()</code></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">    <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">    w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save user program counter.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (killed(p))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">        <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">        <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">        intr_on();</span><br><span class="line"></span><br><span class="line">        syscall();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (killed(p))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="step-6：执行-syscall"><a href="#step-6：执行-syscall" class="headerlink" title="step 6：执行 syscall()"></a>step 6：执行 <code>syscall()</code></h4><p>在 <code>write</code> 的汇编代码中，将参数 <code>SYS_write</code> 存放到了 <code>a7</code> 寄存器中，后保存到了 <code>trapframe</code><br>在 <code>syscall.c</code> 中，从 <code>p-&gt;trapframe-&gt;a7</code> 即可取出参数，这标志的将要执行哪个系统调用</p>
<p>之后从 <code>syscalls[num]</code> 找到对应内核代码的地址，并执行；如果没有找到对应的系统调用将会把返回值 <code>-1</code> 放到 <code>p-&gt;trapframe-a0</code> 中</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">        <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (new)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="step-7：回到-usertrapret-执行-usertrapret"><a href="#step-7：回到-usertrapret-执行-usertrapret" class="headerlink" title="step 7：回到 usertrapret() 执行 usertrapret()"></a>step 7：回到 <code>usertrapret()</code> 执行 <code>usertrapret()</code></h4><blockquote>
<p>#os&#x2F;todo </p>
</blockquote>
<p>此时系统调用已经执行完毕，将要进行恢复用户数据的操作<br>在 <code>usertrapret()</code> 的最后会执行 <code>trampoline.S</code> 中的 <code>userret</code></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">    <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">    <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">    intr_off();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">    uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">    w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">    <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">    p-&gt;trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">    <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">    x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">    x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">    w_sstatus(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">    w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">    uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jump to userret in trampoline.S at the top of memory, which</span></span><br><span class="line">    <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">    <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">    uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">    ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="step-8-执行-trampoline-S-中的-userret"><a href="#step-8-执行-trampoline-S-中的-userret" class="headerlink" title="step 8: 执行 trampoline.S 中的 userret"></a>step 8: 执行 <code>trampoline.S</code> 中的 <code>userret</code></h4><blockquote>
<p>#os&#x2F;todo </p>
</blockquote>
<p>恢复所有的寄存器，pc…</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(pagetable)</span></span><br><span class="line">        <span class="meta"># called by usertrapret() in trap.c to</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        # a0: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">	<span class="meta"># restore user a0</span></span><br><span class="line">        ld a0, <span class="number">112</span>(a0)</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>



<h2 id="如何创建一个新的系统调用？"><a href="#如何创建一个新的系统调用？" class="headerlink" title="如何创建一个新的系统调用？"></a>如何创建一个新的系统调用？</h2><blockquote>
<p>#os&#x2F;todo</p>
</blockquote>
<h3 id="step-1："><a href="#step-1：" class="headerlink" title="step 1："></a>step 1：</h3><p>在如 <code>kernel/sysproc.c</code> <code>kernel/sysfile.c</code> 等等中添加真正要在内核中执行的代码</p>
<p>例如 在 <code>kernel/sysfile.c</code> 中有 <code>write</code> 的内核代码</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    uint64 p;</span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">    argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="step-2："><a href="#step-2：" class="headerlink" title="step 2："></a>step 2：</h3><p>在 <code>kernel/syscall.h</code> 中声明对应系统调用的宏</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22 <span class="comment">// (new)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="step-3："><a href="#step-3：" class="headerlink" title="step 3："></a>step 3：</h3><p>在 <code>kernel/syscall.c</code> 中全局声明系统调用函数，并将其添加进 <code>syscalls</code> 映射表。<br>这样子在执行 <code>syscall()</code> 函数的时候能通过 <code>syscalls</code> 找到系统调用函数的地址</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototypes for the functions that handle system calls.</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] sys_fork,</span><br><span class="line">    [SYS_exit] sys_exit,</span><br><span class="line">    [SYS_wait] sys_wait,</span><br><span class="line">    [SYS_pipe] sys_pipe,</span><br><span class="line">    [SYS_read] sys_read,</span><br><span class="line">    [SYS_kill] sys_kill,</span><br><span class="line">    [SYS_exec] sys_exec,</span><br><span class="line">    [SYS_fstat] sys_fstat,</span><br><span class="line">    [SYS_chdir] sys_chdir,</span><br><span class="line">    [SYS_dup] sys_dup,</span><br><span class="line">    [SYS_getpid] sys_getpid,</span><br><span class="line">    [SYS_sbrk] sys_sbrk,</span><br><span class="line">    [SYS_sleep] sys_sleep,</span><br><span class="line">    [SYS_uptime] sys_uptime,</span><br><span class="line">    [SYS_open] sys_open,</span><br><span class="line">    [SYS_write] sys_write,</span><br><span class="line">    [SYS_mknod] sys_mknod,</span><br><span class="line">    [SYS_unlink] sys_unlink,</span><br><span class="line">    [SYS_link] sys_link,</span><br><span class="line">    [SYS_mkdir] sys_mkdir,</span><br><span class="line">    [SYS_close] sys_close,</span><br><span class="line">    [SYS_trace] sys_trace, <span class="comment">// (new)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>step 4：<br>在 <code>user/usys.pl</code> 中对新的系统调用使用 <code>entry()</code>，使得在生成的 <code>user/usys.S</code> 中有系统调用的汇编代码</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">write:</span><br><span class="line">	li a7, SYS_write</span><br><span class="line">	ecall</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>


<p>step 5：</p>
<p>最后在 user&#x2F;user.h 中添加系统调用函数的声明</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure>

<h2 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.<br>You’ll <strong>create a new trace system call</strong> that will control tracing.<br>It should take <strong>one argument</strong>, an integer “mask”, whose bits specify which system calls to trace.<br>For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h.<br>You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask.<br>The line should <strong>contain the process id, the name of the system call and the return value</strong>;<br>you don’t need to print the system call arguments.<br>The trace system call should enable tracing for the process that calls it and <strong>any children</strong> that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<p>新增一个 system call，用于输出将执行的任务都调用了哪些系统调用<br>注意需要也要输出 fork 出的子进程的系统调用</p>
<ul>
<li>输入：<ul>
<li>其接受一个参数 mask 用于制定哪些系统调用要输出</li>
</ul>
</li>
<li>输出：<ul>
<li>process id</li>
<li>system call name</li>
<li>return value</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br></pre></td></tr></table></figure>




<h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><h4 id="step-1：在-PCB-中添加存储-mask-的-syscall-trace，以及为-syscall-trace-赋初始值-0"><a href="#step-1：在-PCB-中添加存储-mask-的-syscall-trace，以及为-syscall-trace-赋初始值-0" class="headerlink" title="step 1：在 PCB 中添加存储 mask 的 syscall_trace，以及为 syscall_trace 赋初始值 0"></a>step 1：在 <code>PCB</code> 中添加存储 <code>mask</code> 的 <code>syscall_trace</code>，以及为 <code>syscall_trace</code> 赋初始值 <code>0</code></h4><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">    <span class="type">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">    uint64 syscall_trace;        <span class="comment">// (new) 用于记录哪些 syscall 需要被追踪</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="step-2：添加-uint64-sys-trace-void"><a href="#step-2：添加-uint64-sys-trace-void" class="headerlink" title="step 2：添加 uint64 sys_trace(void)"></a>step 2：添加 <code>uint64 sys_trace(void)</code></h4><p>获取 <code>system call</code> 的参数 <code>mask</code> ，将其写到到进程表中 <code>syscall_trace</code><br><code>syscall_trace</code> 是我们在进程表 PCB 中手动加的一个新数据</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">    argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;syscall_trace = mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中用到的 <code>argint</code> 来获取 <code>system call</code> 的参数<br> <code>argint</code> 通过 <code>argraw</code> 访问到 <code>trapframe</code> 来获得参数</p>
<blockquote>
<p>#os&#x2F;q: </p>
</blockquote>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span> &#123;</span><br><span class="line">    *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint64 <span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="step-3：修改-fork-函数，使得-syscall-trace-得以继承"><a href="#step-3：修改-fork-函数，使得-syscall-trace-得以继承" class="headerlink" title="step 3：修改 fork 函数，使得 syscall_trace 得以继承"></a>step 3：修改 <code>fork</code> 函数，使得 <code>syscall_trace</code> 得以继承</h4><blockquote>
<p>#os&#x2F;q</p>
</blockquote>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process.</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy saved user registers.</span></span><br><span class="line">    *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">    np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ofile[i])</span><br><span class="line">            np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">    np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">    safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">    np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="comment">// (new)</span></span><br><span class="line"></span><br><span class="line">    pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;wait_lock);</span><br><span class="line">    np-&gt;parent = p;</span><br><span class="line">    release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;np-&gt;lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="step-4：所有的系统调用都会进入-syscall-函数，我们在这里进行追踪"><a href="#step-4：所有的系统调用都会进入-syscall-函数，我们在这里进行追踪" class="headerlink" title="step 4：所有的系统调用都会进入 syscall 函数，我们在这里进行追踪"></a>step 4：所有的系统调用都会进入 <code>syscall</code> 函数，我们在这里进行追踪</h4><p>因为要输出 <code>syscall</code> 对应的名字（字符串），所以我们可以现在 <code>kernel/syscall.h</code> 中定义一个字符串数组 <code>syscall_names[]</code></p>
<blockquote>
<p>#os&#x2F;q 注意：这个字符数组映射的功能好像在 c++ 中取消了？<br>#os&#x2F;q 为什么字符数组映射不能存在 <code>syscall.h</code> 中</p>
</blockquote>
<p><img src="/../assets/image-20240321183126050.png"></p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall_names[] = &#123;</span><br><span class="line">    [SYS_fork] <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    [SYS_exit] <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">    [SYS_wait] <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">    [SYS_pipe] <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">    [SYS_read] <span class="string">&quot;read&quot;</span>,</span><br><span class="line">    [SYS_kill] <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">    [SYS_exec] <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    [SYS_fstat] <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">    [SYS_chdir] <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">    [SYS_dup] <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">    [SYS_getpid] <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">    [SYS_sbrk] <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">    [SYS_sleep] <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">    [SYS_uptime] <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">    [SYS_open] <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    [SYS_write] <span class="string">&quot;write&quot;</span>,</span><br><span class="line">    [SYS_mknod] <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">    [SYS_unlink] <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">    [SYS_link] <span class="string">&quot;link&quot;</span>,</span><br><span class="line">    [SYS_mkdir] <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">    [SYS_close] <span class="string">&quot;close&quot;</span>,</span><br><span class="line">    [SYS_trace] <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">        <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (new)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight bash"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 961</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 321</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">12: syscall trace -&gt; 0</span><br><span class="line">12: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">12: syscall open -&gt; 3</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 961</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 321</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">12: syscall close -&gt; 0</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line">13: syscall fork -&gt; 14</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 13: syscall fork -&gt; 15</span><br><span class="line">15: syscall fork -&gt; 16</span><br><span class="line">16: syscall fork -&gt; 17</span><br><span class="line">16: syscall fork -&gt; 18</span><br><span class="line">17: syscall fork -&gt; 19</span><br><span class="line">18: syscall fork -&gt; 20</span><br><span class="line">16: syscall fork -&gt; 21</span><br><span class="line">17: syscall fork -&gt; 22</span><br><span class="line">18: syscall fork -&gt; 23</span><br><span class="line">16: syscall fork -&gt; 24</span><br><span class="line">19: syscall fork -&gt; 25</span><br><span class="line">20: syscall fork -&gt; 26</span><br><span class="line">16: syscall fork -&gt; 27</span><br><span class="line">17: syscall fork -&gt; 28</span><br><span class="line">19: syscall fork -&gt; 29</span><br><span class="line">18: syscall fork -&gt; 30</span><br><span class="line">16: syscall fork -&gt; 31</span><br><span class="line">19: syscall fork -&gt; 32</span><br><span class="line">17: syscall fork -&gt; 33</span><br><span class="line">16: syscall fork -&gt; 34</span><br><span class="line">19: syscall fork -&gt; 35</span><br><span class="line">17: syscall fork -&gt; 36</span><br><span class="line">16: syscall fork -&gt; 37</span><br><span class="line">19: syscall fork -&gt; 38</span><br><span class="line">17: syscall fork -&gt; 39</span><br><span class="line">18: syscall fork -&gt; 40</span><br><span class="line">19: syscall fork -&gt; 41</span><br><span class="line">16: syscall fork -&gt; 42</span><br><span class="line">18: syscall fork -&gt; 43</span><br><span class="line">19: syscall fork -&gt; 44</span><br><span class="line">17: syscall fork -&gt; 45</span><br><span class="line">16: syscall fork -&gt; 46</span><br><span class="line">19: syscall fork -&gt; 47</span><br><span class="line">17: syscall fork -&gt; 48</span><br><span class="line">16: syscall fork -&gt; 49</span><br><span class="line">18: syscall fork -&gt; 50</span><br><span class="line">19: syscall fork -&gt; 51</span><br><span class="line">16: syscall fork -&gt; 52</span><br><span class="line">17: syscall fork -&gt; 53</span><br><span class="line">18: syscall fork -&gt; 54</span><br><span class="line">16: syscall fork -&gt; 55</span><br><span class="line">17: syscall fork -&gt; 56</span><br><span class="line">20: syscall fork -&gt; 57</span><br><span class="line">19: syscall fork -&gt; 58</span><br><span class="line">17: syscall fork -&gt; 59</span><br><span class="line">16: syscall fork -&gt; 60</span><br><span class="line">18: syscall fork -&gt; 61</span><br><span class="line">19: syscall fork -&gt; 62</span><br><span class="line">17: syscall fork -&gt; 63</span><br><span class="line">18: syscall fork -&gt; 64</span><br><span class="line">16: syscall fork -&gt; 65</span><br><span class="line">19: syscall fork -&gt; 66</span><br><span class="line">17: syscall fork -&gt; 67</span><br><span class="line">18: syscall fork -&gt; 68</span><br><span class="line">16: syscall fork -&gt; 69</span><br><span class="line">19: syscall fork -&gt; 70</span><br><span class="line">17: syscall fork -&gt; 71</span><br><span class="line">18: syscall fork -&gt; 72</span><br><span class="line">16: syscall fork -&gt; 73</span><br><span class="line">19: syscall fork -&gt; 74</span><br><span class="line">18: syscall fork -&gt; 75</span><br><span class="line">16: syscall fork -&gt; -1</span><br><span class="line">17: syscall fork -&gt; -1</span><br><span class="line">19: syscall fork -&gt; -1</span><br><span class="line">18: syscall fork -&gt; -1</span><br><span class="line">20: syscall fork -&gt; -1</span><br><span class="line">OK</span><br><span class="line">13: syscall fork -&gt; 76</span><br><span class="line">ALL TESTS PASSED</span><br></pre></td></tr></table></figure>

<h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><blockquote>
<p>In this assignment you will <strong>add a system call</strong>, sysinfo, that collects information about the running system.<br>The system call takes <strong>one argument</strong>: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h).<br>The kernel should fill out the fields of this struct: <strong>the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED.</strong><br>We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<p>在这个作业中，您将添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。<br>系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针（参见<code>kernel/sysinfo.h</code>）。<br>内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。<br>我们提供了一个测试程序<code>sysinfotest</code>；如果输出“<code>sysinfotest: OK</code>”则通过。</p>
<p>hint</p>
<ul>
<li>在**<em>Makefile</em><strong>的</strong>UPROGS**中添加<code>$U/_sysinfotest</code></li>
<li>当运行<code>make qemu</code>时，**<em>user&#x2F;sysinfotest.c</em><strong>将会编译失败，遵循和上一个作业一样的步骤添加<code>sysinfo</code>系统调用。要在</strong><em>user&#x2F;user.h</em>**中声明<code>sysinfo()</code>的原型，需要预先声明<code>struct sysinfo</code>的存在：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一旦修复了编译问题，就运行<code>sysinfotest</code>；但由于您还没有在内核中实现系统调用，执行将失败。</p>
<ul>
<li><code>sysinfo</code>需要将一个<code>struct sysinfo</code>复制回用户空间；请参阅<code>sys_fstat()</code>(<strong><em>kernel&#x2F;sysfile.c</em></strong>)和<code>filestat()</code>(<strong><em>kernel&#x2F;file.c</em></strong>)以获取如何使用<code>copyout()</code>执行此操作的示例。</li>
<li>要获取空闲内存量，请在**<em>kernel&#x2F;kalloc.c</em>**中添加一个函数</li>
<li>要获取进程数，请在**<em>kernel&#x2F;proc.c</em>**中添加一个函数</li>
</ul>
<h3 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h3><h4 id="step-1：创建-get-free-mem"><a href="#step-1：创建-get-free-mem" class="headerlink" title="step 1：创建 get_free_mem"></a>step 1：创建 <code>get_free_mem</code></h4><p>用来获取当前<strong>空闲内存大小</strong></p>
<p>在 <code>kernel/defs.h</code> 内核头文件中添加 函数声明</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">get_proc_num</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure>

<p>函数实现</p>
<p><code>xv6</code> 采用的是空闲列表法，把 <code>r</code> 这个列表访问完，看有多少个节点即可<br>每个节点代表一页，大小为 <code>PGSIZE</code> ，<code>4096 KB</code></p>
<p>注意在操作过程中要加锁</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64 <span class="title function_">get_free_mem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.lock); <span class="comment">// 先给内存管理结构加锁</span></span><br><span class="line"></span><br><span class="line">    uint64 mem = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        mem += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中用到的 <code>run</code> 是指向自己类型的指针，<code>kmem</code> 是一个列表和锁</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>


<h4 id="step-2：创建-get-proc-num"><a href="#step-2：创建-get-proc-num" class="headerlink" title="step 2：创建 get_proc_num"></a>step 2：创建 <code>get_proc_num</code></h4><p>用来获取当前<strong>进行的进程数</strong></p>
<p>在 <code>kernel/defs.h</code> 内核头文件中添加 函数声明</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">get_free_mem</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure>

<p>函数实现</p>
<p>统计 <code>proc</code> 中所有非 <code>UNUSED</code> 的状态即可</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64 <span class="title function_">get_proc_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 cnt_proc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED) &#123;</span><br><span class="line">            cnt_proc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt_proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中 proc 中进程 state 一共有 5 种</p>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED,</span><br><span class="line">                 USED,</span><br><span class="line">                 SLEEPING,</span><br><span class="line">                 RUNNABLE,</span><br><span class="line">                 RUNNING,</span><br><span class="line">                 ZOMBIE &#125;;</span><br></pre></td></tr></table></figure>


<h4 id="step-3：创建系统调用-sysinfo"><a href="#step-3：创建系统调用-sysinfo" class="headerlink" title="step 3：创建系统调用 sysinfo"></a>step 3：创建系统调用 <code>sysinfo</code></h4><p>具体的添加操作和前面 <code>trace</code> 类似，我们主要来看函数实现</p>
<p>这里主要是用到了 <code>copyout</code> 来实现从内核中把数据复制到用户中（这样子做的原因是，用户和内核数据进行了隔离，需要用相应的函数进行传输 <code>copyin/copyout</code>）</p>
<blockquote>
<p>#os&#x2F;todo 等有时间来详细说下 <code>copyout</code></p>
</blockquote>
<figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    argaddr(<span class="number">0</span>, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sinfo</span>;</span></span><br><span class="line">    sinfo.freemem = get_free_mem();</span><br><span class="line">    sinfo.nproc = get_proc_num();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;sinfo, <span class="keyword">sizeof</span>(sinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sysinfotest</span><br><span class="line">sysinfotest: start</span><br><span class="line">sysinfotest: OK</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这次的实验感觉已经花费了不少精力，主要在于弄清系统调用是如何一步步的执行的，其中因为用户和内核的隔离又涉及如何进行模式转换 …</p>
<p>最开始了解系统调用是 csapp 中的 shell lab，当时稀里糊涂的就在使用，根本想不到真正执行到那一点系统调用代码，涉及着这么深的东西。</p>
<p>amazing ！</p>
<p>TODO</p>
<ul>
<li>完成本文中的 os&#x2F;todo</li>
<li>完成本文中的 os&#x2F;q (question)</li>
<li>丰富代码的检查机制</li>
<li>完成选做内容</li>
</ul>
<p><img src="/../assets/image-20240323151830407.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/">cs wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.337.search-card.all.click&vd_source=664d223fe65c6706d11206b7416f5b92">MIT6.S081课堂视频</a><br><a target="_blank" rel="noopener" href="https://github.com/duguosheng/6.S081-All-in-one">6.S081-All-in-one</a><br><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">MIT6.S081 视频记录</a><br><a target="_blank" rel="noopener" href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/summary.html">BOOK-RISCV-REV1</a></p>
<p><a target="_blank" rel="noopener" href="https://jborza.com/emulation/2021/04/22/ecalls-and-syscalls.html">Misunderstanding RISC-V ecalls and syscalls</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lilpig/p/17168211.html">xv6系统调用流程——MIT6.S081操作系统</a><br><a target="_blank" rel="noopener" href="https://doraemonzzz.com/tags/6-S081/">doraemonzzz’s blog</a><br><a target="_blank" rel="noopener" href="https://blog.miigon.net/">Miigon’s blog</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weijunji/tag/XV6/">星遥见</a></p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" rel="tag">系统调用</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/03/27/csapp/2024-03-11-%E3%80%90CSAPP%E3%80%91%20ch9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">【CSAPP】 ch9-虚拟内存</a><a class="next" href="/2024/03/07/mit-6-S081-lab/2024-03-07-%E3%80%90MIT%206.S081%E3%80%91%20Lab1-Xv6%20and%20Unix%20utilities/">【MIT 6.S081】 Lab1-Xv6 and Unix utilities</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://note.devilran.xyz"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>To be a better man.</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:admin@domain.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/MIT-6-S081/">MIT 6.S081</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%A1%B5%E8%A1%A8/" style="font-size: 15px;">页表</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 15px;">系统调用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/07/17/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/03/mit-6-S081-lab/2024-04-03-%E3%80%90MIT%206.S081%E3%80%91%20Lab3-Page%20Tables(2022)/">【MIT 6.S081】 Lab3-Page Tables(2022)</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/27/csapp/2024-03-11-%E3%80%90CSAPP%E3%80%91%20ch9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">【CSAPP】 ch9-虚拟内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/mit-6-S081-lab/2024-03-23-%E3%80%90MIT%206.S081%E3%80%91%20Lab2-System%20calls/">【MIT 6.S081】 Lab2-System calls</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/07/mit-6-S081-lab/2024-03-07-%E3%80%90MIT%206.S081%E3%80%91%20Lab1-Xv6%20and%20Unix%20utilities/">【MIT 6.S081】 Lab1-Xv6 and Unix utilities</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Devil.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>